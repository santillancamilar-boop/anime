<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voces del Anime — Inicio</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* ==== Variables y base ==== */
    :root{
      --ink:#111827; --brand:#5b21b6; --muted:#6b7280;
      --grad1:#f0abfc; --grad2:#93c5fd; --grad3:#a7f3d0; --page-max:1200px;
    }
    *{box-sizing:border-box} html,body{margin:0}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      color:var(--ink);
      background:linear-gradient(135deg,#fdf2f8,#eef2ff,#ecfdf5);
      background-attachment:fixed; letter-spacing:.01em;
    }
    .container{max-width:var(--page-max);margin:0 auto;padding:0 16px}
    a{color:#6d28d9;text-decoration:none}

    /* NAV */
    .nav{position:sticky;top:0;z-index:10;background:rgba(255,255,255,.7);backdrop-filter:blur(6px);border-bottom:1px solid #e9d5ff}
    .nav-inner{display:flex;align-items:center;gap:12px;padding:10px 0}
    .brand{font-weight:600;color:#6d28d9}
    .tabs{margin-left:auto;display:flex;gap:12px;flex-wrap:wrap}
    .tab{font-weight:500}
    .tab:hover,.tab:focus-visible{font-weight:600}
    .tab.active{font-weight:800;text-decoration:underline}

    /* HERO */
    .hero{display:flex;flex-direction:column;justify-content:center;align-items:center;padding:40px 0;text-align:center} 
    .hero-logo img{max-width:520px;height:auto;filter:drop-shadow(0 8px 22px rgba(124,58,237,.25))} 
    .lead{margin-top:14px;font-weight:600;font-size:1.2rem;background:linear-gradient(90deg,#7c3aed);-webkit-background-clip:text;background-clip:text;color:transparent}
    .hero-logo{ display:flex; flex-direction:column; align-items:center; } 
    .hero-logo img{ display:block; } /* evita espacios raros bajo el <img> */

    /* BLOQUES */
    .section{padding:32px 0}
    .frame{border-radius:18px;padding:1px;background:linear-gradient(135deg,var(--grad1),var(--grad2),var(--grad3));box-shadow:0 10px 24px rgba(0,0,0,.08);max-width:var(--page-max);margin-inline:auto}
    .glass{border-radius:18px;background:rgba(255,255,255,.65);backdrop-filter:blur(10px);padding:24px}
    .title{font-weight:800;color:#4c1d95;margin:0 0 12px;position:relative;padding-bottom:4px}
    .title::after{content:"";position:absolute;left:0;bottom:-2px;height:3px;width:64px;border-radius:999px;background:linear-gradient(90deg,#a78bfa,#93c5fd,#86efac);opacity:.9}
    .muted{color:var(--muted)}

    /* ===== Reproductor pastel (ajustes visuales) ===== */
    .player{
      display:flex; flex-direction:column; gap:12px;
      max-width:var(--page-max);
      margin:0 auto;
      background:transparent; border:none;
    }
    .header{
      display:flex;align-items:center;justify-content:space-between;gap:12px;padding:14px 16px;
      background:#fff;
      color:var(--brand);
      border-radius:14px 14px 0 0;
      border-bottom:1px solid #D8E6FF;
      backdrop-filter:blur(6px); -webkit-backdrop-filter:blur(6px);
    }
    .player .header .title{ margin:0; font-size:16px; font-weight:700; color:var(--brand); }
    .badge{font-size:12px;padding:6px 10px;border-radius:999px;background:#F4E9FF;color:var(--ink);border:1px solid #EFD9FF}

    .stage{position:relative;background:#000;border-radius:0 0 14px 14px;overflow:hidden}
    video{width:100%;height:auto;display:block;background:#000}
    .center-play{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
    .center-play .btn-big{pointer-events:auto;--size:72px;width:var(--size);height:var(--size);border-radius:999px;border:none;display:grid;place-items:center;font-size:28px;color:white;
      background:linear-gradient(180deg,rgba(0,0,0,.25),rgba(0,0,0,.45));box-shadow:0 10px 30px rgba(0,0,0,.25)}

    .controls{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:14px 16px;padding:14px 16px 12px;background:#F6FAFF;border:1px solid #D8E6FF;border-radius:14px}
    .row{display:flex;align-items:center;gap:8px}
    .controls .row:first-child{grid-column:1/-1;justify-content:center}

    .btn{--size:40px;width:var(--size);height:var(--size);display:grid;place-items:center;border-radius:12px;border:1px solid #D8E6FF;
      background:linear-gradient(180deg,#FFFFFF,#EFF5FF);box-shadow:0 6px 16px rgba(23,15,41,.06);cursor:pointer;color:var(--ink)}
    .btn[aria-pressed="true"]{outline:2px solid #EFD9FF}

    .seek{grid-column:1/-1;display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:10px}
    .time{font-variant-numeric:tabular-nums;color:var(--muted);font-size:14px;min-width:70px;text-align:center}
    .range{position:relative;height:22px;display:grid;align-items:center}
    .buffered,.progress{pointer-events:none;position:absolute;left:0;height:4px;border-radius:999px}
    .buffered{width:0%;background:#FFFFFF}.progress{width:0%;background:linear-gradient(90deg,#7c3aed,#60A5FA,#34D399)}
    input[type="range"].slider{-webkit-appearance:none;width:100%;height:4px;background:transparent}
    input[type="range"].slider::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;border-radius:50%;background:white;border:2px solid var(--brand)}

    .vol{width:min(180px,25vw)}
    input[type="range"].vol-slider{-webkit-appearance:none;width:100%;height:4px;background:#E4EEFF;border-radius:999px}
    input[type="range"].vol-slider::-webkit-slider-thumb{width:14px;height:14px;border-radius:50%;background:var(--brand)}

    .select{padding:8px 10px;border-radius:12px;border:1px solid #D8E6FF;background:linear-gradient(180deg,#fff,#fafafe);color:var(--ink)}
    .foot{color:#6b7280;font-size:13px;padding:10px 16px;border-top:1px solid #e9d5ff;background:#fff}

    .captions{position:absolute;left:0;right:0;bottom:6%;display:flex;flex-direction:column;gap:6px;align-items:center;padding:0 12px;z-index:5}
    .cap-line{max-width:min(86%,900px);color:#111;font-weight:600;line-height:1.35;border-radius:14px;padding:8px 12px;box-shadow:0 6px 20px rgba(0,0,0,.16)}
    .track-ja{background:rgba(167,243,208,.95)} .track-romaji{background:rgba(240,171,252,.95)} .track-es{background:rgba(147,197,253,.95)} .track-en{background:rgba(216,180,254,.95)}

    /* FOOTER */
    .footer{margin-top:36px;border-top:1px solid #e9d5ff;background:rgba(255,255,255,.65)}
    .footer-inner{
      display:grid;gap:20px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
      padding:20px 0;color:#374151;max-width:var(--page-max);margin-inline:auto;
    }
    .footer .title{font-weight:800;color:#5b21b6;margin-bottom:6px}
    ul{margin:0;padding-left:18px}

    /* Tarjetas */
    .functions-grid{ display:grid; gap:14px; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); margin-top:22px; }
    .card{border:1px solid #e9d5ff;border-radius:12px;background:rgba(255,255,255,.92);box-shadow:0 6px 18px rgba(0,0,0,.06);}
    .card-inner{padding:12px 14px}
    .card .title{color:#5b21b6}
    .functions-grid .card{ transition: transform .25s cubic-bezier(.22,1,.36,1), box-shadow .25s, border-color .25s; will-change:transform; }
    .functions-grid .card:hover,.functions-grid .card:focus-within{ transform: translateY(-6px); box-shadow: 0 16px 32px rgba(23,15,41,.14), 0 4px 10px rgba(23,15,41,.06); border-color:#d8b4fe; }
    .functions-grid .card:active{ transform: translateY(-2px); }
    .functions-grid .card:focus-visible{ outline:2px solid #d8b4fe; outline-offset:2px; }
    .functions-grid .card:hover .title{ color:#6d28d9; }

    /* Popover diccionario */
   .popover{
  position: absolute;      /* antes: fixed */
  z-index: 20;             /* encima de captions (z-index:5) */
  min-width:240px; max-width:360px;
  background:#fff;
  border:1px solid #e9d5ff;
  border-radius:14px;
  box-shadow:0 10px 30px rgba(0,0,0,.15);
  padding:10px 12px;
  display:none;
}
    .popover .word{ font-weight:800 }
    .popover .hint{ color:var(--muted); font-size:12px }
    .popover .meaning{ margin-top:6px }
    .popover ul{ margin:6px 0 0 16px; padding:0 }
    .popover li{ margin:4px 0 }
    .popover .ex-ja rt{ font-size:.65em; color:#6b7280 }
    .word-ja{ cursor:pointer; padding:0 2px; border-radius:6px }
    .word-ja:hover{ background:rgba(0,0,0,.06) }
    .track-romaji .word-ro{ cursor:pointer; padding:0 2px; border-radius:6px }
    .hl { outline:2px solid rgba(167,139,250,.45); background:rgba(167,139,250,.12); border-radius:6px }
    ruby{ ruby-position:over; } rt{ font-size:.65em; color:#6b7280 }

    @media (max-width:600px){
      .header{padding:12px}
      .controls{gap:10px 12px;padding:12px}
      .time{min-width:58px;font-size:13px}
    }
  </style>
</head>
<body>
  <!-- NAV -->
  <div class="nav">
    <div class="container nav-inner">
      <a class="brand" href="index.html">Voces del Anime</a>
      <div class="tabs">
        <a class="tab active" href="index.html">Inicio</a>
        <a class="tab" href="lengua.html">Lengua</a>
        <a class="tab" href="cultura.html">Cultura</a>
        <a class="tab" href="comunidad.html">Comunidad</a>
        <a class="tab" href="recursos.html">Recursos</a>
      </div>
    </div>
  </div>

  <main class="main">
    <!-- HERO -->
    <section class="hero">
      <div class="hero-logo">
        <img src="logo-voces.png" alt="Voces del Anime" />
        <h2 class="lead">Explorá el japonés desde sus voces: significado, registro y uso.</h2>
      </div>
    </section>

    <!-- BLOQUE INTRO -->
    <section class="section" aria-labelledby="intro-title">
      <div class="frame">
        <div class="glass" style="text-align:center; padding:40px 28px">
          <h2 id="intro-title" class="title"
              style="color:#5B21B6; font-size:clamp(26px,4vw,34px); margin-bottom:20px; display:inline-block; position:relative; padding-bottom:6px;">
            Bienvenido
          </h2>
<p id="about-copy"
   style="color:#5B21B6; max-width:760px; margin:0 auto 16px; font-size:1.1rem; line-height:1.7; text-align:justify;">
            Este prototipo de sitio web propone empezar a aprender japonés a partir de escenas de anime, uniendo <strong>audio</strong>,
            <strong>subtítulos</strong> y <strong>diccionario</strong>. La idea es que entiendas qué se dice,
            cómo suena y en qué contexto se usa, con una interfaz simple y estética relajante.
          </p>

        <p id="about-copy-2"
   style="color:#5B21B6; max-width:760px; margin:0 auto; font-size:1.1rem; line-height:1.7; text-align:justify;">
            Una herramienta interactiva sería el siguiente reproductor, que permite explorar escenas con subtítulos en
            <strong>japonés</strong>, <strong>rōmaji</strong>, <strong>español</strong> e <strong>inglés</strong>.
            Podés alternar pistas, ajustar velocidad y hacer clic en palabras japonesas para ver su
            <em>lectura</em> y <em>significado</em>.
          </p>
        </div>
      </div>
    </section>

    <!-- BLOQUE REPRODUCTOR -->
    <div class="player" id="player" tabindex="0" aria-label="Reproductor de video con subtítulos y panel flotante">
      <div class="header">
        <h1 class="title">Proyecto integral — Reproductor</h1>
        <span class="badge" id="badgeDur">00:00</span>
      </div>

      <div class="stage">
        <video id="video" preload="metadata" playsinline webkit-playsinline poster="poster.jpg">
          <source id="src" src="video.mp4" type="video/mp4" />
          <track id="trk-ja" label="日本語"   kind="subtitles" srclang="ja"      src="subs-ja.vtt" default />
          <track id="trk-ro" label="Rōmaji"  kind="subtitles" srclang="ja-Latn" src="subs-ro.vtt" />
          <track id="trk-es" label="Español" kind="subtitles" srclang="es"      src="subs-es.vtt" />
          <track id="trk-en" label="Inglés"  kind="subtitles" srclang="en"      src="subs-en.vtt" />
          Tu navegador no soporta la etiqueta <code>video</code>.
        </video>

        <div class="center-play"><button class="btn-big" id="bigPlay" title="Reproducir">▶</button></div>

        <div class="captions" id="captions">
          <div class="cap-line track-ja"     id="cap-ja" hidden></div>
          <div class="cap-line track-romaji" id="cap-romaji" hidden></div>
          <div class="cap-line track-es"     id="cap-es" hidden></div>
          <div class="cap-line track-en"     id="cap-en" hidden></div>
        </div>

        <!-- Popover diccionario -->
        <div class="popover" id="popover">
          <div>
            <span class="word" id="pv-word">—</span>
            <span class="hint" id="pv-roma"></span>
          </div>
          <div class="hint" id="pv-read">Lectura: —</div>
          <div class="meaning" id="pv-meaning">Significado: —</div>
          <div class="hint" id="pv-forms"></div>
          <div class="hint" id="pv-examples"></div>
        </div>
      </div><!-- cierre .stage -->

      <div class="controls" role="group" aria-label="Controles">
        <div class="row">
          <button class="btn" id="back10" title="Retroceder 10s">⟲</button>
          <button class="btn" id="play"   title="Reproducir/Pausar"><span id="icon-play">▶</span></button>
          <button class="btn" id="fwd10"  title="Avanzar 10s">⟳</button>
        </div>
        <div class="row seek" aria-label="Barra de progreso">
          <div class="time" id="currentTime">0:00</div>
          <div class="range">
            <div class="buffered" id="bufferedBar"></div>
            <div class="progress" id="progressBar"></div>
            <input id="seek" class="slider" type="range" min="0" max="1000" step="1" value="0" />
          </div>
          <div class="time" id="duration">0:00</div>
        </div>
        <div class="row">
          <button class="btn" id="mute" title="Silenciar/Activar">🔊</button>
          <div class="vol"><input id="volume" class="vol-slider" type="range" min="0" max="1" step="0.01" value="1" /></div>
        </div>
        <div class="row">
          <select id="speed" class="select" aria-label="Velocidad">
            <option value="0.5">0.5×</option>
            <option value="0.75">0.75×</option>
            <option value="1" selected>1×</option>
            <option value="1.25">1.25×</option>
            <option value="1.5">1.5×</option>
            <option value="1.75">1.75×</option>
            <option value="2">2×</option>
          </select>
          <button class="btn" id="tog-ja"      aria-pressed="true"  title="Alternar Japonés">JA</button>
          <button class="btn" id="tog-romaji"  aria-pressed="false" title="Alternar Rōmaji">RO</button>
          <button class="btn" id="tog-es"      aria-pressed="false" title="Alternar Español">ES</button>
          <button class="btn" id="tog-en"      aria-pressed="false" title="Alternar Inglés">EN</button>
          <button class="btn" id="tog-fg"      aria-pressed="false" title="Furigana en JA">FG</button>
          <button class="btn" id="fs"          title="Pantalla completa">⤢</button>
        </div>
      </div>  
    </div> 

    <!-- BLOQUE: Funciones destacadas -->
    <section class="section" aria-labelledby="feat-title">
      <div class="frame">
        <div class="glass" style="padding:24px">
          <h2 id="feat-title" class="title" style="color:#5B21B6">Funciones destacadas</h2>

          <div class="functions-grid">
            <div class="card"><div class="card-inner">
              <div class="title">Subtítulos multilingües</div>
              <p class="muted">
                Alterná al instante entre <strong>JA</strong> (japonés), <strong>RO</strong> (rōmaji), <strong>ES (español)</strong> e <strong>EN (inglés)</strong> sin recargar el video.
              </p>
            </div></div>

            <div class="card"><div class="card-inner">
              <div class="title">FG: Furigana</div>
              <p class="muted">
                Activá <strong>FG</strong> para mostrar la lectura solo sobre los <em>kanji</em>, facilitando el estudio.
              </p>
            </div></div>

            <div class="card"><div class="card-inner">
              <div class="title">Diccionario emergente</div>
              <p class="muted">
                Hacé clic en una palabra (JA o RO) y aparece un panel con <strong>lectura</strong>, <strong>significado</strong>, <strong>formas</strong> y <strong>ejemplos</strong>.
              </p>
            </div></div>

            <div class="card"><div class="card-inner">
              <div class="title">Sincronía JA ⇄ RO</div>
              <p class="muted">
                Al pasar el mouse o hacer clic, se resalta el segmento equivalente en rōmaji y en japonés.
              </p>
            </div></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- FOOTER -->
  <div class="footer">
    <div class="footer-inner">
      <div>
        <div class="title">Voces del Anime</div>
        <p>Prototipo conceptual para aprendizaje de lengua y cultura japonesa a través del anime.</p>
      </div>
      <div>
        <div class="title">Enlaces</div>
        <ul>
          <li><a href="contacto.html">Contacto</a></li>
          <li><a href="creditos.html">Créditos</a></li>
          <li><a href="politica.html">Política educativa</a></li>
        </ul>
      </div>
      <div>
        <div class="title">Acerca de</div>
        <p>Lengua, cultura y comunidad a través del anime.</p>
      </div>
    </div>
  </div>

  <!-- === Script del reproductor === -->
  <script>
  (function(){
    const $ = (s)=>document.querySelector(s);
    const player=$('#player'), video=$('#video'), srcEl=$('#src');


    const bigPlay=$('#bigPlay'), playBtn=$('#play'), iconPlay=$('#icon-play');
    const back10=$('#back10'), fwd10=$('#fwd10'), seek=$('#seek'),
          progressBar=$('#progressBar'), bufferedBar=$('#bufferedBar');
    const cur=$('#currentTime'), dur=$('#duration'), muteBtn=$('#mute'),
          vol=$('#volume'), speed=$('#speed'), fs=$('#fs'), badgeDur=$('#badgeDur');

    function formatTime(s){
      if(!isFinite(s)) return '0:00';
      const h=Math.floor(s/3600), m=Math.floor((s%3600)/60), sec=String(Math.floor(s%60)).padStart(2,'0');
      return (h>0? h+':'+String(m).padStart(2,'0'):m)+':'+sec;
    }
    video.addEventListener('loadedmetadata',()=>{ dur.textContent=formatTime(video.duration); badgeDur.textContent=formatTime(video.duration); updateBuffered(); });

    function togglePlay(){ (video.paused||video.ended)?video.play():video.pause(); }
    ;[playBtn, video, bigPlay].forEach(el=>el.addEventListener('click', togglePlay));
    video.addEventListener('play', ()=>{ iconPlay.textContent='⏸'; bigPlay.style.display='none'; });
    video.addEventListener('pause', ()=>{ iconPlay.textContent='▶';  bigPlay.style.display='grid'; });

    back10.addEventListener('click', ()=> video.currentTime=Math.max(0, (video.currentTime||0)-10));
    fwd10 .addEventListener('click', ()=> video.currentTime=Math.min(video.duration||0, (video.currentTime||0)+10));

    function updateTime(){
      cur.textContent=formatTime(video.currentTime);
      progressBar.style.width=((video.currentTime/(video.duration||1))*100)+'%';
      seek.value=Math.round((video.currentTime/(video.duration||1))*1000)||0;
    }
    function updateBuffered(){
      try{
        if(video.buffered && video.buffered.length){
          const end=video.buffered.end(video.buffered.length-1);
          bufferedBar.style.width=((end/(video.duration||1))*100)+'%';
        }
      }catch(e){}
    }
    video.addEventListener('timeupdate', updateTime);
    video.addEventListener('progress', updateBuffered);
    video.addEventListener('loadeddata', updateBuffered);
    seek.addEventListener('input', ()=>{ video.currentTime=(seek.value/1000)*(video.duration||0); updateTime(); });

    function updateMuteIcon(){
      const level=video.muted||video.volume===0?0:video.volume;
      muteBtn.textContent= level===0?'🔇':(level<.5?'🔈':'🔊');
    }
    vol.addEventListener('input', ()=>{ video.volume=Number(vol.value); if(video.volume>0) video.muted=false; updateMuteIcon(); });
    muteBtn.addEventListener('click', ()=>{ video.muted=!video.muted; updateMuteIcon(); });
    video.addEventListener('volumechange', updateMuteIcon); updateMuteIcon();

    speed.addEventListener('change', ()=>{ video.playbackRate=Number(speed.value); });
    function toggleFS(){ if(document.fullscreenElement) document.exitFullscreen(); else player.requestFullscreen().catch(()=>{}); }
    fs.addEventListener('click', toggleFS);

    const capJA=$('#cap-ja'), capRO=$('#cap-romaji'), capES=$('#cap-es'), capEN=$('#cap-en');
    const trkJA=$('#trk-ja'), trkRO=$('#trk-ro'), trkES=$('#trk-es'), trkEN=$('#trk-en');
    const togJA=$('#tog-ja'), togRO=$('#tog-romaji'), togES=$('#tog-es'), togEN=$('#tog-en'), togFG=$('#tog-fg');

    const tracks={ ja:trkJA?.track || null, ro:trkRO?.track || null, es:trkES?.track || null, en:trkEN?.track || null };
    Object.values(tracks).forEach(t=>{ if(t){ try{ t.mode='hidden'; }catch(_){} } });

    function armTrack(el){ if(!el) return; const t=el.track; const ok=()=>renderCue(); if(el.readyState===2) ok(); else el.addEventListener('load', ok, {once:true}); }
    armTrack(trkJA); armTrack(trkRO); armTrack(trkES); armTrack(trkEN);

    const state={ showJA:true, showRO:false, showES:false, showEN:false, showFG:false };
    const setToggle=(btn,on)=>btn && btn.setAttribute('aria-pressed', on);
    function syncToggles(){ setToggle(togJA,state.showJA); setToggle(togRO,state.showRO); setToggle(togES,state.showES); setToggle(togEN,state.showEN); setToggle(togFG,state.showFG); }
    function rerenderAndClean(){ renderCue(); clearJAHighlight(); clearROHighlight(); refreshPopoverFG(); }
    syncToggles();
    togJA && togJA.addEventListener('click', ()=>{ state.showJA=!state.showJA; syncToggles(); rerenderAndClean(); });
    togRO && togRO.addEventListener('click', ()=>{ state.showRO=!state.showRO; syncToggles(); rerenderAndClean(); });
    togES && togES.addEventListener('click', ()=>{ state.showES=!state.showES; syncToggles(); rerenderAndClean(); });
    togEN && togEN.addEventListener('click', ()=>{ state.showEN=!state.showEN; syncToggles(); rerenderAndClean(); });
    togFG && togFG.addEventListener('click', ()=>{ state.showFG=!state.showFG; syncToggles(); rerenderAndClean(); });

    /* ======== Diccionario ======== */
    const JA_DICT = {
      "孫悟飯": {
        yomi: "そんごはん",
        gloss: "Son Gohan (nombre propio)",
        ro: "son gohan",
        forms: ["悟飯 (abreviado)", "孫悟飯くん (trato infantil)", "孫悟飯さん (trato neutro)"],
        examples: ["孫悟飯は悟空の息子だ。= Son Gohan es el hijo de Gokū."]
      },
      "正しい": {
        yomi: "ただしい",
        gloss: "correcto; justo",
        ro: "tadashii",
        forms: ["正しく (adv.)", "正しさ (sust.)", "正しくない (neg.)"],
        examples: ["正しい答えを選ぶ。= Elegir la respuesta correcta.", "正しく生きる。= Vivir con rectitud."]
      },
      "こと": {
        yomi: "こと",
        gloss: "cosa; hecho; nominalizador",
        ro: "koto",
        forms: ["V-ことがある (haber hecho/ocurrido)", "V-ことになる (quedar decidido)", "V-ことにする (decidir hacer)"],
        examples: ["日本に行ったことがある。= He estado en Japón.", "出発は明日ということになった。= Se decidió salir mañana."]
      },
      "ために": {
        yomi: "ために",
        gloss: "para; por el bien de / a causa de",
        ro: "tame ni",
        forms: ["N のために (por/para N)", "V-辞書形 ために (para ~)"],
        examples: ["健康のために運動する。= Hago ejercicio por mi salud.", "合格するために勉強する。= Estudio para aprobar."]
      },
      "戦う": {
        yomi: "たたかう",
        gloss: "pelear; luchar",
        ro: "tatakau",
        forms: ["戦って (te-form)", "戦い (sust.)", "戦わない (neg.)", "戦える (potencial)"],
        examples: ["自由のために戦う。= Luchar por la libertad.", "最後まで戦った。= Luchó hasta el final."]
      },
      "罪": {
        yomi: "つみ",
        gloss: "pecado; culpa; delito",
        ro: "tsumi",
        forms: ["有罪 (culpable)", "無罪 (inocente)", "罪人 (criminal)", "罪悪感 (sentimiento de culpa)"],
        examples: ["罪を犯す。= Cometer un delito.", "罪悪感を抱く。= Sentir culpa."]
      },
      "ではない": {
        yomi: "ではない",
        gloss: "no es; negación de だ",
        ro: "de wa nai",
        forms: ["じゃない (coloquial)", "ではありません (formal)"],
        examples: ["それは真実ではない。= Eso no es verdad.", "学生じゃない。= No soy estudiante."]
      },
      "話し合い": {
        yomi: "はなしあい",
        gloss: "diálogo; discusión",
        ro: "hanashiai",
        forms: ["話し合う (verbo)", "話し合いで解決する (resolver por diálogo)"],
        examples: ["問題を話し合いで解決する。= Resolver un problema mediante diálogo."]
      },
      "など": {
        yomi: "など",
        gloss: "etc.; cosas como ~; y así",
        ro: "nado",
        forms: ["N など (entre otros)", "N や N など (N y N, etc.)"],
        examples: ["本や雑誌などを読む。= Leer libros, revistas, etc."]
      },
      "通用しない": {
        yomi: "つうようしない",
        gloss: "no funciona; no surte efecto",
        ro: "tsūyō shinai",
        rov: ["tsuuyou shinai"],
        forms: ["通用する (funcionar; ser válido)", "通用しなかった (pasado neg.)"],
        examples: ["この手は彼には通用しない。= Esta táctica no funciona con él."]
      },
      "相手": {
        yomi: "あいて",
        gloss: "oponente; interlocutor; pareja (de juego/conversación)",
        ro: "aite",
        forms: ["話し相手 (conversador)", "相手にする (tomar en cuenta/tratar con)"],
        examples: ["強い相手だ。= Es un oponente fuerte.", "彼を相手にしない。= No le des bola."]
      },
      "もいるのだ": {
        yomi: "もいるのだ",
        gloss: "también hay/existen (tono explicativo)",
        ro: "mo iru no da",
        forms: ["もいるんだ (coloquial)", "もいるんです (cortés)"],
        examples: ["理解できない人もいるのだ。= También hay gente que no puede entender."],
        note: "のだ/んだ añade matiz explicativo o enfático."
      },
      "いるのだ": {
        yomi: "いるのだ",
        gloss: "hay/está (explicativo; seres animados)",
        ro: "iru no da",
        forms: ["いるんだ (coloquial)", "いるんです (cortés)"],
        examples: ["ここに助けてくれる人がいるのだ。= Aquí hay alguien que puede ayudar."],
        note: "のだ/んだ explica, enfatiza o justifica."
      },
      "精神": {
        yomi: "せいしん",
        gloss: "espíritu; mente; mentalidad",
        ro: "seishin",
        forms: ["精神的 (mental)", "精神力 (fuerza mental)", "精神状態 (estado mental)"],
        examples: ["精神を鍛える。= Fortalecer el espíritu."]
      },
      "光": {
        yomi: "ひかり",
        gloss: "luz",
        ro: "hikari",
        forms: ["光る (brillar)", "日光 (luz solar)", "光景 (escena; vista)"],
        examples: ["光が差し込む。= Entra la luz."]
      },
      "まま": {
        yomi: "まま",
        gloss: "tal cual; manteniendo el estado",
        ro: "mama",
        forms: ["N のまま (tal como N)", "V-た まま (quedarse tras V)", "V-ない まま (sin V)"],
        examples: ["靴のまま入らないで。= No entres con zapatos.", "電気をつけたまま寝た。= Dormí con la luz encendida."],
        note: "X のまま = 'tal como X'. Mantiene estado/situación."
      },
      "自由に": {
        yomi: "じゆうに",
        gloss: "libremente",
        ro: "jiyū ni",
        rov: ["jiyuu ni"],
        forms: ["自由 (sust.)", "自由な (adj.)"],
        examples: ["自由に選んでください。= Elija libremente."]
      },
      "解放してやれ": {
        yomi: "かいほうしてやれ",
        gloss: "¡libéralo! (benefactivo, tono imperativo)",
        ro: "kaihō shite yare",
        rov: ["kaihou shite yare"],
        forms: ["解放する (liberar)", "〜してやる (hacer por alguien; benefactivo ‘yo→vos/él’)"],
        examples: ["精神を光のまま自由に解放してやれ。= Libera el espíritu tal como luz, libremente."],
        note: "してやる: ‘hacerle un favor’ a alguien de estatus similar/inferior; tono cercano."
      },
      "気持ち": {
        yomi: "きもち",
        gloss: "sentimiento; sensación; ánimo",
        ro: "kimochi",
        forms: ["気持ちいい (agradable)", "気持ち悪い (asqueroso/malestar)", "いい気持ち (buen ánimo)", "気持ちになる (sentirse ~)"],
        examples: ["気持ちが分かる。= Entiendo cómo te sentís.", "気持ちいい風だ。= Es un viento agradable."]
      },
      "分かる": {
        yomi: "わかる",
        gloss: "entender; comprender",
        ro: "wakaru",
        forms: ["分かった (pasado)", "分からない (neg.)", "分かりやすい (fácil de entender)", "分かりにくい (difícil de entender)"],
        examples: ["少し日本語が分かる。= Entiendo un poco de japonés.", "意味が分からない。= No entiendo el significado."]
      },
      "もう": {
        yomi: "もう",
        gloss: "ya; más; (frustración) ‘¡basta!’",
        ro: "mō",
        rov: ["mou"],
        forms: ["もうすぐ (muy pronto)", "もう一度 (una vez más)", "もう〜ない (ya no)"],
        examples: ["もう我慢できない。= Ya no puedo aguantar.", "もうすぐ始まる。= Ya empieza."]
      },
      "我慢する": {
        yomi: "がまんする",
        gloss: "aguantarse; soportar; contenerse",
        ro: "gaman suru",
        forms: ["我慢できる/できない (poder/no poder soportar)", "我慢強い (paciente)"],
        examples: ["痛みを我慢する。= Soportar el dolor.", "彼は我慢強い。= Es muy paciente."]
      },
      "ことはない": {
        yomi: "ことはない",
        gloss: "no hace falta; no es necesario / no necesariamente",
        ro: "koto wa nai",
        forms: ["V(辞書形)+ことはない (no es necesario V)", "必ずしも〜ということはない (no necesariamente)"],
        examples: ["心配することはない。= No hace falta preocuparse.", "高いからといって良いということはない。= Que sea caro no significa que sea bueno."]
      },
      "のが": {
        yomi: "のが",
        gloss: "(nominalizador + が: ‘el hecho de ~’ como sujeto)",
        ro: "no ga",
        forms: ["V(辞書形) のが〜 (me/te/le ~ el hecho de V)", "Adj-い のが〜"],
        examples: ["走るのが好きだ。= Me gusta correr.", "早起きするのが苦手だ。= Se me da mal madrugar."]
      },
      /* Partículas (resumen) */
     "を": {
  yomi: "を",
  gloss: "marca de objeto directo; también ruta/espacio atravesado",
  ro: "o",
  rov: ["wo"],                    // <- esta línea es clave
  forms: ["目的語: 水を飲む","経路: 橋を渡る","起点の離脱: 家を出る"],
  examples: ["パンを食べる。= Comer pan."]
},

      "は": { yomi: "は", gloss: "tema; contraste", ro: "wa",
        forms:["主題提示: 私は〜","対比: Aは〜が、Bは〜"],
        examples:["私は学生です。= Yo soy estudiante."] },
      "が": { yomi: "が", gloss: "sujeto; existencia", ro: "ga",
        forms:["新情報提示","存在: 庭に猫がいる"],
        examples:["雨が降っている。= Está lloviendo."] },
      "に": { yomi: "に", gloss: "tiempo; destino; receptor", ro: "ni",
        forms:["時間点: 3時に","到着: 学校に行く"],
        examples:["７時に起きる。= Me levanto a las 7."] },
      "で": { yomi: "で", gloss: "lugar de acción; medio", ro: "de",
        forms:["場所: 学校で","手段: バスで行く"],
        examples:["図書館で読む。= Leer en la biblioteca."] },
      "と": { yomi: "と", gloss: "y; con; cita", ro: "to",
        forms:["並列: AとB","引用: 〜と言う"],
        examples:["家族と住む。= Vivo con mi familia."] },
      "も": { yomi: "も", gloss: "también; incluso", ro: "mo",
        forms:["追加: 私も","強調: 一分もない"],
        examples:["私も行く。= Yo también voy."] },
      "の": { yomi: "の", gloss: "posesivo; nominalizador", ro: "no",
        forms:["私の本","名詞化: 勉強するのが好き"],
        examples:["彼の車。= Su auto."] },
      "へ": { yomi: "へ", gloss: "hacia (dirección)", ro: "e",
        examples:["学校へ急ぐ。= Apurarse hacia la escuela."] },
      "から": { yomi: "から", gloss: "desde; porque", ro: "kara",
        examples:["雨だから行かない。= No voy porque llueve."] },
      "まで": { yomi: "まで", gloss: "hasta; incluso", ro: "made",
        examples:["三時まで勉強する。= Estudio hasta las 3."] },
      "より": { yomi: "より", gloss: "comparativo ‘más que’", ro: "yori",
        examples:["昨日より暖かい。= Más cálido que ayer."] }
    };

    const DICT_KEYS=Object.keys(JA_DICT).sort((a,b)=>b.length-a.length);

    // Segmentación JA priorizando diccionario
    const segJA = (typeof Intl!=='undefined' && Intl.Segmenter)? new Intl.Segmenter('ja',{granularity:'word'}) : null;
    function isKanji(ch){ return /[\u3400-\u9FFF]/.test(ch); }
    function isKana (ch){ return /[\u3040-\u309F\u30A0-\u30FFー]/.test(ch); }
    const kataToHira = s => s.replace(/[\u30A1-\u30F6]/g, c => String.fromCharCode(c.charCodeAt(0)-0x60));

    function sliceWithDict(line){
      const out=[]; let i=0;
      while(i<line.length){
        let m=null;
        for(const k of DICT_KEYS){ if(line.startsWith(k,i)){ m=k; break; } }
        if(m){ const e=JA_DICT[m]; out.push({text:m, dict:e, start:i, end:i+m.length}); i+=m.length; }
        else{ out.push({text:line[i], start:i, end:i+1}); i++; }
      }
      return out;
    }
    function segmentJapanese(line){
      const raw=sliceWithDict(line);
      if(!segJA){ return raw.map(p=> ({text:p.text, start:p.start, end:p.end, dict:p.dict||null})); }
      const out=[]; let buffer='', bStart=null;
      const flush=()=>{
        if(!buffer) return;
        let pos=0;
        for(const it of segJA.segment(buffer)){
          const seg=it.segment;
          const st=bStart + buffer.indexOf(seg,pos);
          const en=st+seg.length;
          pos = buffer.indexOf(seg,pos)+seg.length;
          out.push({text:seg, start:st, end:en, dict:null});
        }
        buffer=''; bStart=null;
      };
      for(const p of raw){
        if(p.dict){ flush(); out.push({text:p.text,start:p.start,end:p.end,dict:p.dict}); }
        else{ if(buffer===''){ buffer=p.text; bStart=p.start; } else buffer+=p.text; }
      }
      flush(); return out;
    }

    /* ======== Romaji helpers ======== */
    const PUNC_RE = /^[\s、。．，！？・：；「」『』（）［］【】〈〉《》〔〕…—.,:;!?-]+$/;
    const ROMA_MAP = {
      'きゃ':'kya','きゅ':'kyu','きょ':'kyo','しゃ':'sha','しゅ':'shu','しょ':'sho','ちゃ':'cha','ちゅ':'chu','ちょ':'cho',
      'にゃ':'nya','にゅ':'nyu','にょ':'nyo','ひゃ':'hya','ひゅ':'hyu','ひょ':'hyo','みゃ':'mya','みゅ':'myu','みょ':'myo',
      'りゃ':'rya','りゅ':'ryu','りょ':'ryo','ぎゃ':'gya','ぎゅ':'gyu','ぎょ':'gyo','じゃ':'ja','じゅ':'ju','じょ':'jo',
      'びゃ':'bya','びゅ':'byu','びょ':'byo','ぴゃ':'pya','ぴゅ':'pyu','ぴょ':'pyo',
      'あ':'a','い':'i','う':'u','え':'e','お':'o','か':'ka','き':'ki','く':'ku','け':'ke','こ':'ko',
      'さ':'sa','し':'shi','す':'su','せ':'se','そ':'so','た':'ta','ち':'chi','つ':'tsu','て':'te','と':'to',
      'な':'na','に':'ni','ぬ':'nu','ね':'ne','の':'no','は':'ha','ひ':'hi','ふ':'fu','へ':'he','ほ':'ho',
      'ま':'ma','み':'mi','む':'mu','め':'me','も':'mo','や':'ya','ゆ':'yu','よ':'yo','ら':'ra','り':'ri','る':'ru','れ':'re','ろ':'ro',
      'わ':'wa','を':'wo','ん':'n','が':'ga','ぎ':'gi','ぐ':'gu','げ':'ge','ご':'go','ざ':'za','じ':'ji','ず':'zu','ぜ':'ze','ぞ':'zo',
      'だ':'da','ぢ':'ji','づ':'zu','で':'de','ど':'do','ば':'ba','び':'bi','ぶ':'bu','べ':'be','ぼ':'bo','ぱ':'pa','ぴ':'pi','ぷ':'pu','ぺ':'pe','ぽ':'po',
      'ぁ':'a','ぃ':'i','ぅ':'u','ぇ':'e','ぉ':'o','ゃ':'ya','ゅ':'yu','ょ':'yo','っ':'','ー':''
    };
    function hiraToRoma(str){
      let out=''; for(let i=0;i<str.length;i++){
        const ch=str[i], next=str[i+1]||'';
        if(ch==='っ' && next){ const roma = ROMA_MAP[next] || ''; if(roma) out += roma[0]; continue; }
        const dig=str.slice(i,i+2);
        if(ROMA_MAP[dig]){ out+=ROMA_MAP[dig]; i++; continue; }
        out += ROMA_MAP[ch] || ch;
      }
      return out;
    }
    const norm = (s)=>{
      if(!s) return '';
      const macPre = {'Ā':'aa','ā':'aa','Ī':'ii','ī':'ii','Ū':'uu','ū':'uu','Ē':'ee','ē':'ee','Ō':'ou','ō':'ou'};
      s = s.replace(/[ĀāĪīŪūĒēŌō]/g, ch => macPre[ch] || ch)
           .replace(/a\u0304/gi,'aa').replace(/i\u0304/gi,'ii')
           .replace(/u\u0304/gi,'uu').replace(/e\u0304/gi,'ee').replace(/o\u0304/gi,'ou');
      return s.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9]/g,'');
    };
// === Variantes de rōmaji por entrada (usa ro + rov[])
function romSetFor(key){
  const e = JA_DICT[key];
  if(!e) return [];
  const list = [e.ro, ...(e.rov || [])].filter(Boolean);
  return list.map(x => norm(x));
}
// Variantes de rōmaji -> listas de tokens normalizados (["kaiho","shite","yare"], ["de","wa","nai"], etc.)
function romVariantsTokensFor(key){
  const e = JA_DICT[key];
  if(!e) return [];
  const cands = [e.ro, ...(e.rov || []), e.yomi ? hiraToRoma(e.yomi) : ''].filter(Boolean);
  return cands
    .map(s => tokenizeRoma(s))   // usa norm() por dentro
    .filter(arr => arr.length);
}

    function makeRubyKanjiOnly(surface, yomi){
      if(!surface || !yomi) return surface;
      const y = kataToHira(yomi);
      const chars = Array.from(surface);

      // anclar kana presentes en la palabra dentro de la lectura
      let p=0;
      const anchors=[];
      for(let i=0;i<chars.length;i++){
        const ch = chars[i];
        if(isKana(ch)){
          const h = kataToHira(ch);
          const q = y.indexOf(h, p);
          if(q !== -1){ anchors.push({i, q, len:h.length}); p = q + h.length; }
        }
      }

      let lastY = 0, out = '';
      const findAnchorFrom = (idx) => anchors.find(a => a.i >= idx);

      for(let i=0;i<chars.length;){
        if(isKanji(chars[i])){
          let j=i; while(j<chars.length && isKanji(chars[j])) j++;
          const next = findAnchorFrom(j);
          const endY = next ? next.q : y.length;
          let read = y.slice(lastY, endY);
          const group = chars.slice(i, j).join('');
          out += `<ruby><rb>${group}</rb><rt>${read}</rt></ruby>`;
          lastY = endY;
          i = j;
        }else{
          out += chars[i];
          const a = anchors.find(a => a.i === i);
          if(a) lastY = Math.max(lastY, a.q + a.len);
          i++;
        }
      }
      return out;
    }

    // Ruby para oraciones de ejemplos: aplica furigana sólo a palabras que estén en el diccionario y tengan yomi
    function rubyKnownWordsInJa(jp){
      if(!jp) return '';
      let i=0, out='';
      while(i<jp.length){
        let hit=null;
        for(const k of DICT_KEYS){
          if(!JA_DICT[k]?.yomi) continue;
          if(jp.startsWith(k,i)){
            hit=k; break;
          }
        }
        if(hit){
          const y=JA_DICT[hit].yomi;
          // si la clave tiene kanji, aplicamos ruby; si es todo kana, dejamos tal cual
          const hasKanji = Array.from(hit).some(isKanji);
          out += hasKanji ? makeRubyKanjiOnly(hit, y) : hit;
          i += hit.length;
        }else{
          out += jp[i];
          i++;
        }
      }
      return out;
    }

    /* ======== Render ======== */
    function renderLine(track, el, mode){
      const show = (state.showJA && mode==='ja') ||
                   (state.showRO && mode==='ro') ||
                   (state.showES && mode==='es') ||
                   (state.showEN && mode==='en');
      if(!show){ el.hidden=true; el.innerHTML=''; return; }

      // localizar cue activo
      let cue=null;
      if(track?.activeCues?.length) cue=track.activeCues[0];
      else if(track?.cues?.length){
        const t=video.currentTime;
        for(let i=0;i<track.cues.length;i++){
          const c=track.cues[i];
          if(t>=c.startTime && t<=c.endTime){ cue=c; break; }
        }
      }
      if(!cue){ el.hidden=true; el.innerHTML=''; return; }

      el.hidden=false; el.innerHTML='';
      const lines = cue.text.split(/\r?\n/);

      for(let li=0; li<lines.length; li++){
        const lineText = lines[li];

        if(mode==='ja'){
          const tokens = segmentJapanese(lineText);
          const wrap = document.createElement('span');
          wrap.className = 'line-ja';
          wrap.dataset.text = lineText;

          tokens.forEach((tok, idx) => {
            const sp = document.createElement('span');
            sp.className = 'word-ja';

            const hasKanji = Array.from(tok.text).some(isKanji);

            if (state.showFG && tok.dict && hasKanji) {
              sp.innerHTML = makeRubyKanjiOnly(tok.text, tok.dict.yomi);
            } else {
              sp.textContent = tok.text;
            }

            sp.dataset.word  = tok.text.trim();
            sp.dataset.start = tok.start;
            sp.dataset.end   = tok.end;
            sp.dataset.idx   = idx;

            if (tok.dict) {
              sp.dataset.dict  = '1';
              sp.dataset.yomi  = tok.dict.yomi  || '';
              sp.dataset.gloss = tok.dict.gloss || '';
              if (tok.dict.ro)   sp.dataset.roma = tok.dict.ro;
              if (tok.dict.note) sp.dataset.note = tok.dict.note;
            } else {
              sp.dataset.dict = '0';
            }

            wrap.appendChild(sp);
          });

          el.appendChild(wrap);

        } else if(mode==='ro'){
          const parts = lineText.split(/(\s+|[.,!?¡¿…:;()\[\]'"-])/).filter(Boolean);
          let idx=0;
          parts.forEach(tok=>{
            if(/\s+|[.,!?¡¿…:;()\[\]'"-]/.test(tok)){
              el.appendChild(document.createTextNode(tok));
            }else{
              const sp=document.createElement('span');
              sp.className='word-ro';
              sp.textContent=tok;
              sp.dataset.norm = norm(tok);
              sp.dataset.idx = String(idx++);
              el.appendChild(sp);
            }
          });

        } else {
          el.appendChild(document.createTextNode(lineText));
        }

        if(li<lines.length-1) el.appendChild(document.createElement('br'));
      }
    }

    function renderCue(){
      renderLine(tracks.ja,capJA,'ja');
      renderLine(tracks.ro,capRO,'ro');
      renderLine(tracks.es,capES,'es');
      renderLine(tracks.en,capEN,'en');
    }
    Object.values(tracks).forEach(t=>{ t && t.addEventListener('cuechange', renderCue); });
    video.addEventListener('timeupdate', renderCue);
    video.addEventListener('seeked', renderCue);
    video.addEventListener('ratechange', renderCue);
    window.addEventListener('load', renderCue);

    /* ======== Popover + highlight ======== */
    const pop=$('#popover'),
          pvWord=$('#pv-word'),
          pvRead=$('#pv-read'),
          pvMeaning=$('#pv-meaning'),
          pvRoma=$('#pv-roma'),
          pvForms=$('#pv-forms'),
          pvExamples=$('#pv-examples');

    let popLocked=false, popAnchor=null, lastEntry=null; // para refrescar cuando cambie FG

    function lockPopover(anchor){ popLocked=true; popAnchor=anchor||popAnchor; pop.setAttribute('data-locked','1'); }
    function unlockPopover(){ popLocked=false; popAnchor=null; pop.removeAttribute('data-locked'); }
  // Popover limitado al área del video (.stage)
function placePopoverAtSpan(span, force=false){
  if (popLocked && !force) return;

  const stage = document.querySelector('.stage');
  if (!stage) return;

  const sr = stage.getBoundingClientRect(); // contenedor (video)
  const r  = span.getBoundingClientRect();  // ancla
  const margin = 8;

  // mostrar para medir tamaño
  pop.style.visibility = 'hidden';
  pop.style.display = 'block';
  const pr = pop.getBoundingClientRect();

  // coordenadas RELATIVAS a .stage
  let top  = r.top  - sr.top  - pr.height - 12;       // arriba del ancla
  if (top < margin) top = r.bottom - sr.top + 12;     // si no entra, abajo

  let left = r.left - sr.left + (r.width - pr.width)/2;
  left = Math.max(margin, Math.min(left, sr.width  - pr.width  - margin));
  top  = Math.max(margin, Math.min(top , sr.height - pr.height - margin));

  pop.style.left = left + 'px';
  pop.style.top  = top  + 'px';
  pop.style.visibility = 'visible';
}

function repositionIfNeeded(){
  if (!popLocked || !popAnchor || !document.body.contains(popAnchor)) return;
  placePopoverAtSpan(popAnchor, true);
}

// Ya no hace falta reposicionar en scroll
// window.addEventListener('scroll', repositionIfNeeded, { passive: true });
window.addEventListener('resize', repositionIfNeeded);
    function longestDictAt(line, pos){
      let best = null;
      for (const k of DICT_KEYS){
        let from = 0, i;
        while ((i = line.indexOf(k, from)) !== -1){
          const j = i + k.length;
          if (i <= pos && pos < j){
            if (!best || k.length > best.text.length){
              best = { text:k, start:i, end:j, entry: JA_DICT[k] };
            }
          }
          from = i + 1;
          if (from >= line.length) break;
        }
      }
      return best;
    }

    // helpers de highlight

    function roTokens(){ return Array.from(capRO.querySelectorAll('.word-ro')); }
function roNorms(){ return roTokens().map(t=>t.dataset.norm || ''); }
function tokenizeRoma(str){ return (str||'').trim().split(/\s+/).map(norm).filter(Boolean); }

// escoge la variante de rōmaji que realmente aparece en la línea (p. ej. “wo” sobre “o”)
function pickBestRoVariant(entry){
  const cands = [entry?.ro, ...(entry?.rov||[]), entry?.yomi ? hiraToRoma(entry.yomi) : '']
    .filter(Boolean).map(s=>s.trim()).filter(Boolean);
  const norms = roNorms();
  for(const c of cands){ if(norms.includes(norm(c))) return c; }
  return cands[0] || '';
}

// resalta la ocurrencia correcta en JA (útil si hay varias iguales)
function highlightJaFromRo(key, roStartIndex){
  clearJAHighlight();
  const spans   = Array.from(capJA.querySelectorAll('.word-ja'));
  const targets = spans.filter(sp => sp.dataset.word === key);
  if (targets.length){ targets[0].classList.add('hl'); return true; }

  const wrap=capJA.querySelector('.line-ja');
  const line=wrap?(wrap.dataset.text||''):'';
  const pos=line.indexOf(key);
  if(pos>=0){
    spans.forEach(sp=>{
      const s=Number(sp.dataset.start)||0, e2=Number(sp.dataset.end)||0;
      if(s<pos+key.length && e2>pos) sp.classList.add('hl');
    });
    return true;
  }
  // último recurso por rōmaji
  const byRoSet=new Set(romSetFor(key));
  let did=false;
  spans.forEach(sp=>{
    const r=sp.dataset.roma || (sp.dataset.yomi ? hiraToRoma(sp.dataset.yomi) : '');
    if(r && byRoSet.has(norm(r))){ sp.classList.add('hl'); did=true; }
  });
  return did;
}

    let roBadgeEl=null;
    function clearROHighlight(){
      capRO.querySelectorAll('.hl').forEach(el=>el.classList.remove('hl'));
      if(roBadgeEl && roBadgeEl.parentNode) roBadgeEl.parentNode.removeChild(roBadgeEl);
      roBadgeEl=null;
    }
    function clearJAHighlight(){ capJA.querySelectorAll('.hl').forEach(el=>el.classList.remove('hl')); }

    function highlightInRO(romaji){
      clearROHighlight();
      if(!state.showRO || !romaji) return;
      const target = norm(romaji);
      const toks = Array.from(capRO.querySelectorAll('.word-ro'));
      const norms = toks.map(t=>t.dataset.norm||'');

      for(let i=0;i<norms.length;i++){
        let cat='';
        for(let j=i;j<norms.length;j++){
          cat += norms[j];
          if(cat===target){
            for(let k=i;k<=j;k++) toks[k].classList.add('hl');
            return;
          }
          if(cat.length >= target.length) break;
        }
      }
      for(let i=0;i<norms.length;i++){ if(norms[i]===target){ toks[i].classList.add('hl'); return; } }
      let pick=-1, bestLen=0;
      for(let i=0;i<norms.length;i++){
        const n=norms[i];
        if(n.includes(target) || target.includes(n)){ if(n.length>bestLen){ pick=i; bestLen=n.length; } }
      }
      if(pick!==-1){ toks[pick].classList.add('hl'); return; }
      roBadgeEl=document.createElement('span'); roBadgeEl.className='ro-badge'; roBadgeEl.textContent=romaji; capRO.appendChild(roBadgeEl);
    }

    /* === HOVER: Japonés -> Romaji (si RO visible) === */
capJA.addEventListener('mousemove', (e)=>{
  if(!state.showJA) return;

  const t = e.target && e.target.nodeType===3 ? e.target.parentElement : e.target;
  const jaSpan = t.closest('.word-ja');

  clearJAHighlight();

  // ignorar si no es palabra o si es sólo puntuación
  if(!jaSpan || PUNC_RE.test(jaSpan.textContent)){
    if(state.showRO) clearROHighlight();
    return;
  }

  // resalto la palabra JA bajo el cursor
  jaSpan.classList.add('hl');

  // si RO no está visible, no intento sincronizar
  if(!state.showRO) return;

  // reconstruyo la entrada de diccionario para esta posición
  const wrap = jaSpan.closest('.line-ja');
  const lineText = wrap ? (wrap.dataset.text || '') : '';
  const start = Number(jaSpan.dataset.start)||0;
  const end   = Number(jaSpan.dataset.end)||start+(jaSpan.textContent||'').length;
  const mid   = Math.floor((start+end)/2);

  let surface = jaSpan.dataset.word || (jaSpan.textContent||'').trim();
  let entry = (jaSpan.dataset.dict==='1')
    ? (JA_DICT[surface] || {
        yomi: jaSpan.dataset.yomi,
        ro:   jaSpan.dataset.roma
      })
    : null;

  // si no venía marcada como diccionario, busco la mejor coincidencia en la línea
  if(!entry){
    const best = longestDictAt(lineText, mid);
    if(best){ surface = best.text; entry = best.entry; }
  }

  // si detecté un término, resalto el span/segmento completo JA (multi-kanji)
  if(surface && wrap){
    const jStart = (wrap.dataset.text || '').indexOf(surface);
    if(jStart >= 0){
      capJA.querySelectorAll('.word-ja').forEach(sp=>{
        const s = Number(sp.dataset.start)||0, e2 = Number(sp.dataset.end)||0;
        if(s < jStart + surface.length && e2 > jStart) sp.classList.add('hl');
      });
    }
  }

// y reflejo en RO (prefiere la variante que está en la línea: "wo" u "o")
const romaPreferred = entry ? pickBestRoVariant(entry) : '';
  const directRoma    = !entry && Array.from(surface).every(isKana)
    ? hiraToRoma(kataToHira(surface))
    : '';
  const romaOut = romaPreferred || directRoma;
  if (romaOut) highlightInRO(romaOut);
}); // ← cerrar AQUÍ el mousemove de JA ✅

// limpiar cuando salgo del bloque JA (fuera del mousemove)
capJA.addEventListener('mouseleave', ()=>{
  clearJAHighlight();
  if(state.showRO) clearROHighlight();
});

/* === HOVER: Romaji -> Japonés (si JA visible) — usa variantes tokenizadas === */
capRO.addEventListener('mousemove', (e)=>{
  if(!state.showRO) return;

  const roSpan = e.target.closest('.word-ro');
  clearROHighlight();

  if(!roSpan){
    if(state.showJA) clearJAHighlight();
    return;
  }

  roSpan.classList.add('hl');
  if(!state.showJA) return;

  // tokens y formas normalizadas de la línea RO
  const toks   = roTokens();
  const norms  = roNorms();
  const idx    = toks.indexOf(roSpan);
  const cur    = norms[idx]; // token actual bajo el cursor (p. ej. "wa", "shite", "wo")

  // Ventanas que INCLUYEN idx (tamaños 1..4), probando a izquierda y derecha
  const windows = [];
  for (let w = 4; w >= 1; w--) {
    const minStart = Math.max(0, idx - (w - 1));
    const maxStart = Math.min(idx, norms.length - w);
    for (let start = minStart; start <= maxStart; start++) {
      const end = start + w - 1;
      const seg = norms.slice(start, end + 1);
      windows.push({ start, end, text: seg.join('') });
    }
  }

  // Matching contra el diccionario usando variantes tokenizadas
  let best = null;
  for (const winCand of windows) {
    for (const k of DICT_KEYS) {
      const variants = romVariantsTokensFor(k); // arrays de tokens: ["kaiho","shite","yare"], ["de","wa","nai"], ["wo"], etc.
      for (const rvTokens of variants) {
        if (!rvTokens.includes(cur)) continue;           // el token bajo el cursor debe estar en la variante
        if (rvTokens.join('') === winCand.text) {        // y la ventana debe calzar EXACTO (sin espacios)
          if (!best || rvTokens.length > best.rvLen) {
            best = { k, entry: JA_DICT[k], win: winCand, rvLen: rvTokens.length };
          }
        }
      }
    }
  }
  if (!best) return;

  // highlight en RO
  for(let i = best.win.start; i <= best.win.end; i++){ toks[i].classList.add('hl'); }

  // highlight en JA (directo por clave; si no, por rōmaji)
  clearJAHighlight();
  let found = false;
  capJA.querySelectorAll('.word-ja').forEach(sp=>{
    if(sp.dataset.word === best.k){ sp.classList.add('hl'); found = true; }
  });

  if(!found){
    const wrap = capJA.querySelector('.line-ja');
    const line = wrap ? (wrap.dataset.text || '') : '';
    const pos  = line.indexOf(best.k);
    if(pos >= 0){
      capJA.querySelectorAll('.word-ja').forEach(sp=>{
        const s = Number(sp.dataset.start)||0, e2 = Number(sp.dataset.end)||0;
        if(s < pos + best.k.length && e2 > pos) sp.classList.add('hl');
      });
    }else{
      // último recurso: comparar rōmaji normalizado
      const byRoSet = new Set(romVariantsTokensFor(best.k).map(arr => arr.join('')));
      capJA.querySelectorAll('.word-ja').forEach(sp=>{
        const r = sp.dataset.roma || (sp.dataset.yomi ? hiraToRoma(sp.dataset.yomi) : '');
        if(r && byRoSet.has(norm(r))) sp.classList.add('hl');
      });
    }
  }
});


capRO.addEventListener('mouseleave', ()=>{
  clearROHighlight();
  if(state.showJA) clearJAHighlight();
});

    /* === POPUP Helpers === */
    function fillExtra(entry){
      // Rōmaji al lado del término
      pvRoma.textContent = entry?.ro ? ` · ${entry.ro}` : '';

      // Formas
      if (entry?.forms?.length){
        pvForms.innerHTML = `<div><strong>Formas:</strong></div><ul>
          ${entry.forms.map(f=>`<li>${f}</li>`).join('')}
        </ul>`;
      } else {
        pvForms.innerHTML = '';
      }

      // Ejemplos (con furigana opcional por FG)
      if (entry?.examples?.length){
        const items = entry.examples.map(ex=>{
          const parts = ex.split('=');
          const ja = parts[0] ? parts[0].trim() : '';
          const es = parts[1] ? parts[1].trim() : '';
          const jaOut = state.showFG ? rubyKnownWordsInJa(ja) : ja;
          return `<li><span class="ex-ja">${jaOut}</span>${es? ` = <span class="ex-es">${es}</span>`:''}</li>`;
        }).join('');
        pvExamples.innerHTML = `<div><strong>Ejemplos:</strong></div><ul>${items}</ul>`;
      } else {
        pvExamples.innerHTML = '';
      }
    }

    function refreshPopoverFG(){
      if(pop.style.display==='block' && lastEntry){
        // volver a pintar ejemplos con/ sin furigana según FG
        fillExtra(lastEntry);
        if(popAnchor) placePopoverAtSpan(popAnchor, true);
      }
    }

   /* === CLICK EN JAPO: popover + sincroniza RO (con forms/ejemplos) === */
document.addEventListener('click',(e)=>{
  if(!state.showJA) return;

  // Cerrar si el clic fue fuera de JA y fuera del popover

  if(!capJA.contains(e.target)) {
    if(!e.target.closest('#popover')) { pop.style.display='none'; unlockPopover(); }
    return;
  }

  // Normalizar target (por si el click cayó en un textNode dentro del span)
  const t = e.target && e.target.nodeType===3 ? e.target.parentElement : e.target;
  const span = t.closest('.word-ja');
  if(!span) return;

  // Ignorar signos de puntuación
  if (PUNC_RE.test(span.textContent)) return;

  const lineWrap = span.closest('.line-ja');
  const lineText = lineWrap ? (lineWrap.dataset.text || '') : '';
  const start = Number(span.dataset.start)||0;
  const end   = Number(span.dataset.end)||start+(span.textContent||'').length;
  const pos   = Math.floor((start+end)/2);

  let surface = span.dataset.word || (span.textContent||'').trim();

  // si venía marcado por el diccionario, intentamos recuperar la ENTRADA COMPLETA
  let entry = (span.dataset.dict==='1') ? (JA_DICT[surface] || {
    yomi:  span.dataset.yomi,
    gloss: span.dataset.gloss,
    ro:    span.dataset.roma,
    note:  span.dataset.note
  }) : null;

  // si no hay entrada directa, buscamos la mejor coincidencia en la línea (máxima longitud)
  if(!entry){
    const best = longestDictAt(lineText, pos);
    if(best){ surface = best.text; entry = best.entry; }
  }

  // completar campos del popover
  pvWord.textContent = surface;
  pvRead.textContent = 'Lectura: ' + (entry?.yomi || '—');
  pvMeaning.textContent = 'Significado: ' + (entry?.gloss || '—') + (entry?.note ? ' · Uso: ' + entry.note : '');
  fillExtra(entry);
  lastEntry = entry || null;

  // mostrar y posicionar
  unlockPopover();
  pop.style.display = 'block';
  placePopoverAtSpan(span);
  lockPopover(span);

  // resaltar en RO (prefiere la variante que está en la línea: "wo" u "o")
  const romaPreferred = entry ? pickBestRoVariant(entry) : '';
  const directRoma    = !entry && Array.from(surface).every(isKana)
    ? hiraToRoma(kataToHira(surface))
    : '';
  const romaOut = romaPreferred || directRoma;
  if (romaOut) highlightInRO(romaOut);
}, true);
/* === CLICK EN ROMAJI: popover + reflejo JA (con ro + rov) === */
document.addEventListener('click',(e)=>{
  if(!state.showRO) return;
  if(!capRO.contains(e.target)) return;

  const roSpan = e.target.closest('.word-ro'); if(!roSpan) return;

  const toks = Array.from(capRO.querySelectorAll('.word-ro'));
  const idx  = toks.indexOf(roSpan);
  const get  = i => (i>=0 && i<toks.length)? toks[i].textContent.trim() : null;

  // candidatos de 1..4 tokens
  const candidates = [];
  for (let w=4; w>=1; w--) {
    for (let start=idx-(w-1); start<=idx; start++) {
      if (start<0) continue;
      const parts=[];
      for (let k=0;k<w;k++){ const t=get(start+k); if(!t){ parts.length=0; break; } parts.push(t); }
      if(parts.length) candidates.push({start, end:start+w-1, text:parts.join(' ')});
    }
  }

  // match por ro + rov
  let match=null, entry=null, key=null;
  for (const cand of candidates) {
    const cn = norm(cand.text);
    for (const k of DICT_KEYS) {
      if (romSetFor(k).includes(cn)) { match=cand; entry=JA_DICT[k]; key=k; break; }
    }
    if (match) break;
  }
  if(!entry || !match) return;

  // Popover
  pvWord.textContent = key;
  pvRead.textContent = 'Lectura: ' + (entry.yomi || '—');
  pvMeaning.textContent = 'Significado: ' + (entry.gloss || '—') + (entry.note ? ' · Uso: ' + entry.note : '');
  fillExtra(entry);
  lastEntry = entry;

  unlockPopover();
  pop.style.display = 'block';
  placePopoverAtSpan(roSpan);
  lockPopover(roSpan);

  // highlight correcto en RO
  clearROHighlight();
  for (let i = match.start; i <= match.end; i++) toks[i].classList.add('hl');

  // reflejo en JA
  if (state.showJA) {
    clearJAHighlight();
    const spans = Array.from(capJA.querySelectorAll('.word-ja'));
    const wrap = capJA.querySelector('.line-ja');
    const lineText = wrap ? (wrap.dataset.text || '') : '';
    let jStart = lineText.indexOf(key);
    if (jStart >= 0) {
      spans.forEach(sp=>{
        const s = Number(sp.dataset.start)||0, e2 = Number(sp.dataset.end)||0;
        if (s < jStart + key.length && e2 > jStart) sp.classList.add('hl');
      });
    } else {
      const byRoSet = new Set(romSetFor(key));
      spans.forEach(sp=>{
        const r = sp.dataset.roma || (sp.dataset.yomi ? hiraToRoma(sp.dataset.yomi) : '');
        if (r && byRoSet.has(norm(r))) sp.classList.add('hl');
      });
    }
  }
}, true);

    // limpieza global
    document.addEventListener('mouseleave', ()=>{ clearJAHighlight(); clearROHighlight(); }, true);
    // inicial
    renderCue();
  })();
  </script>
</body>
</html>
